import argparse
from board import Board, floatToString
import math
from copy import copy
from collections import defaultdict
from line import Line, Vector, dist, dot, cross, intersect, applySplits, kdtree, kdnear, kdinside
from fillettracks import filletTracks
from teardrops import SetTeardrops
import os

# todo: 
# check for fillets first and share space with subdivision rounding
#  - see 5V end stop junction on print head board
# rectangular pad teardrops?    

def subdivideTracks(tracks, vias, board, args):
    maxCosTheta = math.cos(math.radians(args.minAngle))
    radius = args.radius * 0.1
    maxRadius = args.maxRadius * 0.1
    minLength = args.minLength * 0.1
    for t in tracks:
        t.i = 0 # iteration number
    #find all connected tracks
    intersections = findIntersections(tracks, vias, args)
    # perform track subdivision smoothing algorithm as explained 
    # here https://mitxela.com/projects/melting_kicad           
    for smoothpass in range(args.passes):
        # save original lengths
        for t in tracks:
           t.originalLength = t.length
        nextPassIntersections = defaultdict(list)
        for (x, y), tracksHere in intersections.items():
            # flip tracks such that all tracks start at the intersection point
            island = tracksHere[0].island
            for t in tracksHere:
                assert(t.island == island)
                if t.start.x != x or t.start.y != y:
                    t.reverse()
        
            #sort these tracks by angle, so new tracks can be drawn between them
            tracksHere.sort(key = Line.angle)

            #find the largest angle between two tracks
            cosAnglesBetweenTracks = []
            for t in range(len(tracksHere)):
                t0, t1 = tracksHere[t - 1], tracksHere[t]
                #skip pairs that won't be smoothed (see below)
                if smoothpass == 0 or t0.i != t1.i:
                    cosAnglesBetweenTracks.append(abs(dot(t0.dir, t1.dir)))
            #skip if tracks already smooth/straight enough
            if (len(cosAnglesBetweenTracks) == 0 or
                min(cosAnglesBetweenTracks) > maxCosTheta):
                continue
            
            #shorten all these tracks (push start points away from intersection point)
            shortestTrackLen = min(t.originalLength for t in tracksHere)
            for t in range(len(tracksHere)):
                t0, t1 = tracksHere[t - 1], tracksHere[t]
                r = min(maxRadius, radius + args.radiusWidthMultiplier * t0.width, t0.length - minLength)
                cosHalfTheta = math.sqrt(.5 + .5 * abs(dot(t0.dir, t1.dir)))
                amountToShorten = min(shortestTrackLen / (2 * cosHalfTheta + 2), r)
                if amountToShorten >= minLength:
                    t0.length -= amountToShorten
                    t0.start = t0.pointOnLine(amountToShorten)
                    nextPassIntersections[t0.start].append(t0)

            #connect the new start points in a circle around the old center point
            for t in range(len(tracksHere)):
                t0, t1 = tracksHere[t - 1], tracksHere[t]
                #don't add 2 new tracks in the 2 track case
                if len(tracksHere) > 2 or t == 1:
                    # don't link two tracks that were both generated by a previous pass
                    # to stop 3+ way junctions going fractal
                    if smoothpass == 0 or t0.i != t1.i:
                        thinTrack = t0 if t0.width < t1.width else t1
                        t = copy(thinTrack)
                        t.start = t0.start
                        t.end = t1.start
                        t.i = smoothpass + 1
                        if t.update():
                            tracks.append(t)
                            nextPassIntersections[t.start].append(t)
                            nextPassIntersections[t.end].append(t)
        intersections = nextPassIntersections

def findIntersections(tracks, vias, args):
    # remove empty tracks
    tracks = [t for t in tracks if t.length > 0]

    #find all connected tracks
    intersections = defaultdict(list)
    for t in tracks:
        intersections[t.start].append(t)
        intersections[t.end].append(t)

    # remove intersections with fewer than 2 tracks
    if args.smoothnway:
        # only allow more than 2 tracks if n-way option is set
        for pos in list(intersections):
            tracksHere = intersections[pos]
            if len(tracksHere) < 2:
                intersections.pop(pos)
    else:
        for pos in list(intersections):
            tracksHere = intersections[pos]
            if len(tracksHere) != 2:
                intersections.pop(pos)

    # make a kd-tree for faster searching
    tracktree = kdtree(list(intersections.items()))

    # remove intersections with vias    
    for v in vias:
        for pos, t in kdnear(tracktree, v.pos, v.diameter * .5):
            intersections.pop(pos)

    # remove junctions with unrelated tracks intersecting them
    maxWidth = max(t.width for t in tracks)
    for t1 in tracks:
        # expand the bounding box by the max track width to find all track intersections
        for pos, othertracks in kdinside(tracktree, t1.bounds(expand = maxWidth * .5)):
            if pos not in intersections:
                continue
            for t2 in othertracks:
                if t1.island != t2.island:
                    if t1.distanceTo(pos) < (t1.width + t2.width) * .5: # and t.i == 0
                        intersections.pop(pos)
                        break

    return intersections

def main():
    parser = argparse.ArgumentParser(description = "Round off the corners of copper tracks in an EasyEDA board json file")
    parser.add_argument('filename', help="input file")
    parser.add_argument('outputfile', help="outfile file", nargs="?")
    parser.add_argument('--radius', help="Radius to round 90 degree corners to (in mils)", type=float, default=5.0)
    parser.add_argument('--radiusWidthMultiplier', help="Corner radius is expanded by the width of the track multiplied by this value", type=float, default=0.5)
    parser.add_argument('--maxRadius', help="Maximum corner radius (in mils)", type=float, default=100.0)
    parser.add_argument('--minAngle', help="Stop rounding when angle between two tracks is smaller than this", type=float, default=5.0)
    parser.add_argument('--minLength', help="Stop rounding when track segments are shorter than this (mils)", type=float, default=2.5)
    parser.add_argument('--passes', help="Number of passes to make over each track during smoothing", type=int, default=3)
    parser.add_argument('--teardropLength', help="Length of teardrops as a percentage of pad diameter", type=float, default=50)
    parser.add_argument('--teardropWidth', help="Width of teardrops as a percentage", type=float, default=90)
    parser.add_argument('--teardropSegs', help="Number of curve segments to create for teardrops", type=int, default=10)
    parser.add_argument('--smoothnway', help="Apply rounding on n-way junctions (fillets will normally work better)", action='store_true')
    parser.add_argument('--nosubdivide', help="Don't run track smoothing subdivision algorithm", action='store_true')
    parser.add_argument('--nofillet', help="Don't add fillets on any corners that couldn't be rounded", action='store_true')
    parser.add_argument('--noteardrops', help="Don't add teardrops", action='store_true')
    args = parser.parse_args()
    print(f'Loading board "{args.filename}"')
    board = Board()
    board.load(args.filename)
    if not args.nosubdivide:
        print("Subdividing tracks")
        for tracks in board.tracksByNetAndLayer.values():
            net = tracks[0].net
            vias = board.viasByNet.get(net, [])
            subdivideTracks(tracks, vias, board, args)
    if not args.nofillet:
        print("Applying fillets")
        for tracks in board.tracksByNetAndLayer.values():
            filletTracks(tracks, board, args)
    if not args.noteardrops:
        print("Applying teardrops")
        for tracks in board.tracksByNetAndLayer.values():
            vias = board.viasByNet.get(tracks[0].net, [])
            SetTeardrops(board, tracks, vias, args)
    outname = args.outputfile
    if not outname:
        name, ext = os.path.splitext(args.filename)
        outname = name + '_smoothed' + ext
    print(f'Saving board "{outname}"')
    board.save(outname)

if __name__ == '__main__':
    main()